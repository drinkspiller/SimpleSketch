import { Injectable, inject } from '@angular/core';
import { ComponentStore } from '@ngrx/component-store';
import { ReplaySubject, combineLatest, debounceTime, filter, fromEvent, of, switchMap, takeUntil, tap, zip, } from 'rxjs';
import { WINDOW } from '../injection-tokens';
import { Mode } from '../toolbar/toolbar.component';
import * as i0 from "@angular/core";
const INITIAL_STATE = {
    backgroundColor: '#000000',
    isSketching: false,
    lastX: 0,
    lastY: 0,
    lineWidth: 5,
    mode: Mode.SKETCH,
    paintColor: '#ffffff',
};
export class SimpleSketchCanvasStore extends ComponentStore {
    canvas$ = new ReplaySubject(1);
    context$ = new ReplaySubject(1);
    window = inject(WINDOW);
    /**
     * +-------------------------------------------+
     * SELECTORS
     * +-------------------------------------------+
     */
    backgroundColor$ = this.select(state => state.backgroundColor);
    isSketching$ = this.select(state => state.isSketching);
    lineWidth$ = this.select(state => state.lineWidth);
    mode$ = this.select(state => state.mode);
    paintColor$ = this.select(state => state.paintColor);
    lastPosition$ = this.select(state => ({
        x: state.lastX,
        y: state.lastY,
    }));
    /**
     * +-------------------------------------------+
     * UPDATERS
     * +-------------------------------------------+
     */
    updateBackGroundColor = this.updater((state, newBackgroundColor) => ({
        ...state,
        backgroundColor: newBackgroundColor,
    }));
    updateIsSketching = this.updater((state, isSketching) => ({
        ...state,
        isSketching,
    }));
    updatePaintColor = this.updater((state, newPaintColor) => ({
        ...state,
        paintColor: newPaintColor,
    }));
    updateMode = this.updater((state, newMode) => ({
        ...state,
        mode: newMode,
    }));
    updateLastPosition = this.updater((state, newPosition) => ({
        ...state,
        lastX: newPosition.x,
        lastY: newPosition.y,
    }));
    /**
     * +-------------------------------------------+
     * EFFECTS
     * +-------------------------------------------+
     */
    applyBackgroundColor = this.effect(() => {
        return combineLatest([this.backgroundColor$, this.canvas$]).pipe(tap(([color, canvas]) => {
            if (canvas) {
                canvas.style.backgroundColor = color;
            }
        }));
    });
    clearCanvas = this.effect(trigger$ => combineLatest([trigger$, this.context$, this.canvas$]).pipe(tap(([, context, canvas]) => {
        if (context && canvas) {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }
    })));
    init = this.effect((data$) => {
        return data$.pipe(tap(([canvas, backgroundColor, paintColor]) => {
            const context = canvas.getContext('2d');
            // Initialize canvas & context properties using the supplied `canvas`.
            this.canvas$.next(canvas);
            this.context$.next(context);
            // Canvases must have their width and height pixel values set. The
            // canvas' _parent (`.canvas-wrapper`), flexes to grow to the
            // available space. Set the actual canvas element to the pixel
            // dimensions available inside its parent.
            const canvasWrapper = canvas.parentElement;
            const canvasWrapperSize = this.getElementSizeMinusPadding(canvasWrapper);
            this.updateCanvasSize([
                canvasWrapperSize.width,
                canvasWrapperSize.height,
            ]);
            // Update property values in component state.
            this.updateBackGroundColor(backgroundColor);
            this.updatePaintColor(paintColor);
            this.applyBackgroundColor();
            // Subscribe to resize events so the canvas' pixel dimensions redraw
            // using the values from the post-resize available space.
            fromEvent(this.window, 'resize')
                .pipe(takeUntil(this.destroy$), debounceTime(75))
                .subscribe(() => {
                const canvasWrapperSize = this.getElementSizeMinusPadding(canvasWrapper);
                this.updateCanvasSize([
                    canvasWrapperSize.width,
                    canvasWrapperSize.height,
                ]);
            });
        }));
    });
    sketch = this.effect((event$) => {
        return event$.pipe(switchMap(event => zip(of(event), this.context$, this.isSketching$, this.lineWidth$, this.paintColor$, this.mode$, this.lastPosition$)), tap(([event, context, isSketching, lineWidth, paintColor, mode, lastPosition,]) => {
            event.preventDefault();
            const screenPosition = this.getEventPosition(event, context.canvas);
            if (isSketching && context) {
                context.beginPath();
                context.lineCap = 'round';
                context.lineJoin = 'round';
                context.strokeStyle = paintColor;
                if (mode === Mode.SKETCH) {
                    context.lineWidth = lineWidth;
                    context.globalCompositeOperation = 'source-over';
                }
                else if (mode === Mode.ERASE) {
                    // Make the eraser larger than the finer point brush used for
                    // sketching.
                    context.lineWidth = lineWidth * 5;
                    context.globalCompositeOperation = 'destination-out';
                }
                else {
                    console.error('Unexpected or empty mode.');
                }
                context.moveTo(lastPosition.x, lastPosition.y);
                context.lineTo(screenPosition.x, screenPosition.y);
                context.stroke();
                this.updateLastPosition(screenPosition);
            }
        }));
    });
    startSketch = this.effect((event$) => {
        return combineLatest([event$, this.context$]).pipe(tap(([event, context]) => {
            event.preventDefault();
            this.updateIsSketching(true);
            const screenPosition = this.getEventPosition(event, context.canvas);
            this.updateLastPosition(screenPosition);
        }));
    });
    stopSketch = this.effect((event$) => {
        return event$.pipe(tap((event) => {
            event.preventDefault();
            this.updateIsSketching(false);
        }));
    });
    updateCanvasSize = this.effect((args$) => {
        return args$.pipe(switchMap(([width, height]) => {
            return combineLatest([
                this.canvas$,
                this.context$,
                of(width),
                of(height),
            ]);
        }), filter(
        /* eslint-disable @typescript-eslint/no-unused-vars */
        ([canvas, context, width, height]) => canvas !== null && context !== null), tap(([canvas, context, width, height]) => {
            // Resizing the canvas will clear its contents, so store the current
            // canvas contents before resizing so they can be restored after.
            const currentCanvasContent = context.getImageData(0, 0, canvas.width, canvas.height);
            // Now resize the canvas
            canvas.width = width;
            canvas.height = height;
            // Reapply saved contents/
            context.putImageData(currentCanvasContent, 0, 0);
        }));
    });
    /**
     * +-------------------------------------------+
     * CLASS METHODS
     * +-------------------------------------------+
     */
    /**
     * Takes a mousemove or touchmove event and return the corresponding position
     * on the screen where the event occurred.
     */
    getEventPosition(event, element) {
        const x = (event.pageX ??
            event.targetTouches[0].pageX) - element.offsetLeft;
        const y = (event.pageY ??
            event.targetTouches[0].pageY) - element.offsetTop;
        return { x, y };
    }
    /** Returns the size of a supplied element, minus its padding. */
    getElementSizeMinusPadding(element) {
        const computedStyle = this.window.getComputedStyle(element);
        const width = element.clientWidth -
            (parseFloat(computedStyle.paddingLeft) +
                parseFloat(computedStyle.paddingRight));
        const height = element.clientHeight -
            (parseFloat(computedStyle.paddingTop) +
                parseFloat(computedStyle.paddingBottom));
        return { width, height };
    }
    constructor() {
        super(INITIAL_STATE);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: SimpleSketchCanvasStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: SimpleSketchCanvasStore });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: SimpleSketchCanvasStore, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmFzLnN0b3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3NpbXBsZS1za2V0Y2gvY2FudmFzL2NhbnZhcy5zdG9yZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNqRCxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDckQsT0FBTyxFQUVMLGFBQWEsRUFDYixhQUFhLEVBQ2IsWUFBWSxFQUNaLE1BQU0sRUFDTixTQUFTLEVBQ1QsRUFBRSxFQUNGLFNBQVMsRUFDVCxTQUFTLEVBQ1QsR0FBRyxFQUNILEdBQUcsR0FDSixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUMzQyxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sOEJBQThCLENBQUM7O0FBWWxELE1BQU0sYUFBYSxHQUE0QjtJQUM3QyxlQUFlLEVBQUUsU0FBUztJQUMxQixXQUFXLEVBQUUsS0FBSztJQUNsQixLQUFLLEVBQUUsQ0FBQztJQUNSLEtBQUssRUFBRSxDQUFDO0lBQ1IsU0FBUyxFQUFFLENBQUM7SUFDWixJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU07SUFDakIsVUFBVSxFQUFFLFNBQVM7Q0FDdEIsQ0FBQztBQWFGLE1BQU0sT0FBTyx1QkFBd0IsU0FBUSxjQUF1QztJQUMxRSxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQW9CLENBQUMsQ0FBQyxDQUFDO0lBQ2xELFFBQVEsR0FBRyxJQUFJLGFBQWEsQ0FBMkIsQ0FBQyxDQUFDLENBQUM7SUFDMUQsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUVoQzs7OztPQUlHO0lBQ00sZ0JBQWdCLEdBQXVCLElBQUksQ0FBQyxNQUFNLENBQ3pELEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FD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YSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDNUMsTUFBTSxNQUFNLEdBQ1YsT0FBTyxDQUFDLFlBQVk7WUFDcEIsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztnQkFDbkMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFTLENBQUM7SUFDakMsQ0FBQztJQUVEO1FBQ0UsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7dUdBeFNVLHVCQUF1QjsyR0FBdkIsdUJBQXVCOzsyRkFBdkIsdUJBQXVCO2tCQURuQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3RhYmxlLCBpbmplY3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRTdG9yZX0gZnJvbSAnQG5ncngvY29tcG9uZW50LXN0b3JlJztcbmltcG9ydCB7XG4gIE9ic2VydmFibGUsXG4gIFJlcGxheVN1YmplY3QsXG4gIGNvbWJpbmVMYXRlc3QsXG4gIGRlYm91bmNlVGltZSxcbiAgZmlsdGVyLFxuICBmcm9tRXZlbnQsXG4gIG9mLFxuICBzd2l0Y2hNYXAsXG4gIHRha2VVbnRpbCxcbiAgdGFwLFxuICB6aXAsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtXSU5ET1d9IGZyb20gJy4uL2luamVjdGlvbi10b2tlbnMnO1xuaW1wb3J0IHtNb2RlfSBmcm9tICcuLi90b29sYmFyL3Rvb2xiYXIuY29tcG9uZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVTa2V0Y2hDYW52YXNTdGF0ZSB7XG4gIGJhY2tncm91bmRDb2xvcjogc3RyaW5nO1xuICBpc1NrZXRjaGluZzogYm9vbGVhbjtcbiAgbGFzdFg6IG51bWJlcjtcbiAgbGFzdFk6IG51bWJlcjtcbiAgbGluZVdpZHRoOiBudW1iZXI7XG4gIG1vZGU6IE1vZGU7XG4gIHBhaW50Q29sb3I6IHN0cmluZztcbn1cblxuY29uc3QgSU5JVElBTF9TVEFURTogU2ltcGxlU2tldGNoQ2FudmFzU3RhdGUgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJyMwMDAwMDAnLFxuICBpc1NrZXRjaGluZzogZmFsc2UsXG4gIGxhc3RYOiAwLFxuICBsYXN0WTogMCxcbiAgbGluZVdpZHRoOiA1LFxuICBtb2RlOiBNb2RlLlNLRVRDSCxcbiAgcGFpbnRDb2xvcjogJyNmZmZmZmYnLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBQb2ludCB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpemUge1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgd2lkdGg6IG51bWJlcjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNpbXBsZVNrZXRjaENhbnZhc1N0b3JlIGV4dGVuZHMgQ29tcG9uZW50U3RvcmU8U2ltcGxlU2tldGNoQ2FudmFzU3RhdGU+IHtcbiAgcHJpdmF0ZSBjYW52YXMkID0gbmV3IFJlcGxheVN1YmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+KDEpO1xuICBwcml2YXRlIGNvbnRleHQkID0gbmV3IFJlcGxheVN1YmplY3Q8Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEPigxKTtcbiAgcHJpdmF0ZSB3aW5kb3cgPSBpbmplY3QoV0lORE9XKTtcblxuICAvKipcbiAgICogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqIFNFTEVDVE9SU1xuICAgKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICovXG4gIHJlYWRvbmx5IGJhY2tncm91bmRDb2xvciQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuc2VsZWN0KFxuICAgIHN0YXRlID0+IHN0YXRlLmJhY2tncm91bmRDb2xvclxuICApO1xuXG4gIHJlYWRvbmx5IGlzU2tldGNoaW5nJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IHRoaXMuc2VsZWN0KFxuICAgIHN0YXRlID0+IHN0YXRlLmlzU2tldGNoaW5nXG4gICk7XG5cbiAgcmVhZG9ubHkgbGluZVdpZHRoJDogT2JzZXJ2YWJsZTxudW1iZXI+ID0gdGhpcy5zZWxlY3QoXG4gICAgc3RhdGUgPT4gc3RhdGUubGluZVdpZHRoXG4gICk7XG5cbiAgcmVhZG9ubHkgbW9kZSQ6IE9ic2VydmFibGU8TW9kZT4gPSB0aGlzLnNlbGVjdChzdGF0ZSA9PiBzdGF0ZS5tb2RlKTtcblxuICByZWFkb25seSBwYWludENvbG9yJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5zZWxlY3QoXG4gICAgc3RhdGUgPT4gc3RhdGUucGFpbnRDb2xvclxuICApO1xuXG4gIHJlYWRvbmx5IGxhc3RQb3NpdGlvbiQ6IE9ic2VydmFibGU8UG9pbnQ+ID0gdGhpcy5zZWxlY3Qoc3RhdGUgPT4gKHtcbiAgICB4OiBzdGF0ZS5sYXN0WCxcbiAgICB5OiBzdGF0ZS5sYXN0WSxcbiAgfSkpO1xuXG4gIC8qKlxuICAgKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogVVBEQVRFUlNcbiAgICogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqL1xuICByZWFkb25seSB1cGRhdGVCYWNrR3JvdW5kQ29sb3IgPSB0aGlzLnVwZGF0ZXIoXG4gICAgKHN0YXRlLCBuZXdCYWNrZ3JvdW5kQ29sb3I6IHN0cmluZykgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBuZXdCYWNrZ3JvdW5kQ29sb3IsXG4gICAgfSlcbiAgKTtcblxuICByZWFkb25seSB1cGRhdGVJc1NrZXRjaGluZyA9IHRoaXMudXBkYXRlcigoc3RhdGUsIGlzU2tldGNoaW5nOiBib29sZWFuKSA9PiAoe1xuICAgIC4uLnN0YXRlLFxuICAgIGlzU2tldGNoaW5nLFxuICB9KSk7XG5cbiAgcmVhZG9ubHkgdXBkYXRlUGFpbnRDb2xvciA9IHRoaXMudXBkYXRlcigoc3RhdGUsIG5ld1BhaW50Q29sb3I6IHN0cmluZykgPT4gKHtcbiAgICAuLi5zdGF0ZSxcbiAgICBwYWludENvbG9yOiBuZXdQYWludENvbG9yLFxuICB9KSk7XG5cbiAgcmVhZG9ubHkgdXBkYXRlTW9kZSA9IHRoaXMudXBkYXRlcigoc3RhdGUsIG5ld01vZGU6IE1vZGUpID0+ICh7XG4gICAgLi4uc3RhdGUsXG4gICAgbW9kZTogbmV3TW9kZSxcbiAgfSkpO1xuXG4gIHJlYWRvbmx5IHVwZGF0ZUxhc3RQb3NpdGlvbiA9IHRoaXMudXBkYXRlcigoc3RhdGUsIG5ld1Bvc2l0aW9uOiBQb2ludCkgPT4gKHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXN0WDogbmV3UG9zaXRpb24ueCxcbiAgICBsYXN0WTogbmV3UG9zaXRpb24ueSxcbiAgfSkpO1xuXG4gIC8qKlxuICAgKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogRUZGRUNUU1xuICAgKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICovXG4gIHJlYWRvbmx5IGFwcGx5QmFja2dyb3VuZENvbG9yID0gdGhpcy5lZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFt0aGlzLmJhY2tncm91bmRDb2xvciQsIHRoaXMuY2FudmFzJF0pLnBpcGUoXG4gICAgICB0YXAoKFtjb2xvciwgY2FudmFzXSkgPT4ge1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH0pO1xuXG4gIHJlYWRvbmx5IGNsZWFyQ2FudmFzID0gdGhpcy5lZmZlY3QodHJpZ2dlciQgPT5cbiAgICBjb21iaW5lTGF0ZXN0KFt0cmlnZ2VyJCwgdGhpcy5jb250ZXh0JCwgdGhpcy5jYW52YXMkXSkucGlwZShcbiAgICAgIHRhcCgoWywgY29udGV4dCwgY2FudmFzXSkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjYW52YXMpIHtcbiAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcblxuICByZWFkb25seSBpbml0ID0gdGhpcy5lZmZlY3QoXG4gICAgKGRhdGEkOiBPYnNlcnZhYmxlPFtIVE1MQ2FudmFzRWxlbWVudCwgc3RyaW5nLCBzdHJpbmddPikgPT4ge1xuICAgICAgcmV0dXJuIGRhdGEkLnBpcGUoXG4gICAgICAgIHRhcCgoW2NhbnZhcywgYmFja2dyb3VuZENvbG9yLCBwYWludENvbG9yXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAvLyBJbml0aWFsaXplIGNhbnZhcyAmIGNvbnRleHQgcHJvcGVydGllcyB1c2luZyB0aGUgc3VwcGxpZWQgYGNhbnZhc2AuXG4gICAgICAgICAgdGhpcy5jYW52YXMkLm5leHQoY2FudmFzKTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQkLm5leHQoY29udGV4dCBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpO1xuXG4gICAgICAgICAgLy8gQ2FudmFzZXMgbXVzdCBoYXZlIHRoZWlyIHdpZHRoIGFuZCBoZWlnaHQgcGl4ZWwgdmFsdWVzIHNldC4gVGhlXG4gICAgICAgICAgLy8gY2FudmFzJyBfcGFyZW50IChgLmNhbnZhcy13cmFwcGVyYCksIGZsZXhlcyB0byBncm93IHRvIHRoZVxuICAgICAgICAgIC8vIGF2YWlsYWJsZSBzcGFjZS4gU2V0IHRoZSBhY3R1YWwgY2FudmFzIGVsZW1lbnQgdG8gdGhlIHBpeGVsXG4gICAgICAgICAgLy8gZGltZW5zaW9ucyBhdmFpbGFibGUgaW5zaWRlIGl0cyBwYXJlbnQuXG4gICAgICAgICAgY29uc3QgY2FudmFzV3JhcHBlciA9IGNhbnZhcy5wYXJlbnRFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgIGNvbnN0IGNhbnZhc1dyYXBwZXJTaXplID1cbiAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudFNpemVNaW51c1BhZGRpbmcoY2FudmFzV3JhcHBlcik7XG5cbiAgICAgICAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUoW1xuICAgICAgICAgICAgY2FudmFzV3JhcHBlclNpemUud2lkdGgsXG4gICAgICAgICAgICBjYW52YXNXcmFwcGVyU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgcHJvcGVydHkgdmFsdWVzIGluIGNvbXBvbmVudCBzdGF0ZS5cbiAgICAgICAgICB0aGlzLnVwZGF0ZUJhY2tHcm91bmRDb2xvcihiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgIHRoaXMudXBkYXRlUGFpbnRDb2xvcihwYWludENvbG9yKTtcblxuICAgICAgICAgIHRoaXMuYXBwbHlCYWNrZ3JvdW5kQ29sb3IoKTtcblxuICAgICAgICAgIC8vIFN1YnNjcmliZSB0byByZXNpemUgZXZlbnRzIHNvIHRoZSBjYW52YXMnIHBpeGVsIGRpbWVuc2lvbnMgcmVkcmF3XG4gICAgICAgICAgLy8gdXNpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBwb3N0LXJlc2l6ZSBhdmFpbGFibGUgc3BhY2UuXG4gICAgICAgICAgZnJvbUV2ZW50KHRoaXMud2luZG93LCAncmVzaXplJylcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSwgZGVib3VuY2VUaW1lKDc1KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjYW52YXNXcmFwcGVyU2l6ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFbGVtZW50U2l6ZU1pbnVzUGFkZGluZyhjYW52YXNXcmFwcGVyKTtcblxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUoW1xuICAgICAgICAgICAgICAgIGNhbnZhc1dyYXBwZXJTaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGNhbnZhc1dyYXBwZXJTaXplLmhlaWdodCxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICApO1xuXG4gIHJlYWRvbmx5IHNrZXRjaCA9IHRoaXMuZWZmZWN0KFxuICAgIChldmVudCQ6IE9ic2VydmFibGU8TW91c2VFdmVudCB8IFRvdWNoRXZlbnQ+KSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnQkLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcChldmVudCA9PlxuICAgICAgICAgIHppcChcbiAgICAgICAgICAgIG9mKGV2ZW50KSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCQsXG4gICAgICAgICAgICB0aGlzLmlzU2tldGNoaW5nJCxcbiAgICAgICAgICAgIHRoaXMubGluZVdpZHRoJCxcbiAgICAgICAgICAgIHRoaXMucGFpbnRDb2xvciQsXG4gICAgICAgICAgICB0aGlzLm1vZGUkLFxuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb24kXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICB0YXAoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGlzU2tldGNoaW5nLFxuICAgICAgICAgICAgbGluZVdpZHRoLFxuICAgICAgICAgICAgcGFpbnRDb2xvcixcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBsYXN0UG9zaXRpb24sXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuUG9zaXRpb24gPSB0aGlzLmdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRleHQuY2FudmFzKTtcbiAgICAgICAgICAgIGlmIChpc1NrZXRjaGluZyAmJiBjb250ZXh0KSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcGFpbnRDb2xvcjtcblxuICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gTW9kZS5TS0VUQ0gpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gTW9kZS5FUkFTRSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGVyYXNlciBsYXJnZXIgdGhhbiB0aGUgZmluZXIgcG9pbnQgYnJ1c2ggdXNlZCBmb3JcbiAgICAgICAgICAgICAgICAvLyBza2V0Y2hpbmcuXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGggKiA1O1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBvciBlbXB0eSBtb2RlLicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8obGFzdFBvc2l0aW9uLngsIGxhc3RQb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0UG9zaXRpb24oc2NyZWVuUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICk7XG5cbiAgcmVhZG9ubHkgc3RhcnRTa2V0Y2ggPSB0aGlzLmVmZmVjdChcbiAgICAoZXZlbnQkOiBPYnNlcnZhYmxlPE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50PikgPT4ge1xuICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoW2V2ZW50JCwgdGhpcy5jb250ZXh0JF0pLnBpcGUoXG4gICAgICAgIHRhcCgoW2V2ZW50LCBjb250ZXh0XSkgPT4ge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVJc1NrZXRjaGluZyh0cnVlKTtcblxuICAgICAgICAgIGNvbnN0IHNjcmVlblBvc2l0aW9uID0gdGhpcy5nZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250ZXh0LmNhbnZhcyk7XG4gICAgICAgICAgdGhpcy51cGRhdGVMYXN0UG9zaXRpb24oc2NyZWVuUG9zaXRpb24pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICk7XG5cbiAgcmVhZG9ubHkgc3RvcFNrZXRjaCA9IHRoaXMuZWZmZWN0KFxuICAgIChldmVudCQ6IE9ic2VydmFibGU8TW91c2VFdmVudCB8IFRvdWNoRXZlbnQ+KSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnQkLnBpcGUoXG4gICAgICAgIHRhcCgoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUlzU2tldGNoaW5nKGZhbHNlKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICApO1xuXG4gIHJlYWRvbmx5IHVwZGF0ZUNhbnZhc1NpemUgPSB0aGlzLmVmZmVjdChcbiAgICAoYXJncyQ6IE9ic2VydmFibGU8W251bWJlciwgbnVtYmVyXT4pID0+IHtcbiAgICAgIHJldHVybiBhcmdzJC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoKFt3aWR0aCwgaGVpZ2h0XSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzJCxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCQsXG4gICAgICAgICAgICBvZih3aWR0aCksXG4gICAgICAgICAgICBvZihoZWlnaHQpLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9KSxcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICAgICAgICAgIChbY2FudmFzLCBjb250ZXh0LCB3aWR0aCwgaGVpZ2h0XSkgPT5cbiAgICAgICAgICAgIGNhbnZhcyAhPT0gbnVsbCAmJiBjb250ZXh0ICE9PSBudWxsXG4gICAgICAgICksXG4gICAgICAgIHRhcCgoW2NhbnZhcywgY29udGV4dCwgd2lkdGgsIGhlaWdodF0pID0+IHtcbiAgICAgICAgICAvLyBSZXNpemluZyB0aGUgY2FudmFzIHdpbGwgY2xlYXIgaXRzIGNvbnRlbnRzLCBzbyBzdG9yZSB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIGNhbnZhcyBjb250ZW50cyBiZWZvcmUgcmVzaXppbmcgc28gdGhleSBjYW4gYmUgcmVzdG9yZWQgYWZ0ZXIuXG4gICAgICAgICAgY29uc3QgY3VycmVudENhbnZhc0NvbnRlbnQgPSBjb250ZXh0IS5nZXRJbWFnZURhdGEoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGNhbnZhcyEud2lkdGgsXG4gICAgICAgICAgICBjYW52YXMhLmhlaWdodFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBOb3cgcmVzaXplIHRoZSBjYW52YXNcbiAgICAgICAgICBjYW52YXMhLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgY2FudmFzIS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAvLyBSZWFwcGx5IHNhdmVkIGNvbnRlbnRzL1xuICAgICAgICAgIGNvbnRleHQhLnB1dEltYWdlRGF0YShjdXJyZW50Q2FudmFzQ29udGVudCwgMCwgMCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgKTtcblxuICAvKipcbiAgICogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqIENMQVNTIE1FVEhPRFNcbiAgICogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUYWtlcyBhIG1vdXNlbW92ZSBvciB0b3VjaG1vdmUgZXZlbnQgYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvblxuICAgKiBvbiB0aGUgc2NyZWVuIHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZC5cbiAgICovXG4gIHByaXZhdGUgZ2V0RXZlbnRQb3NpdGlvbihcbiAgICBldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQsXG4gICAgZWxlbWVudDogSFRNTENhbnZhc0VsZW1lbnRcbiAgKTogUG9pbnQge1xuICAgIGNvbnN0IHggPVxuICAgICAgKChldmVudCBhcyBNb3VzZUV2ZW50KS5wYWdlWCA/P1xuICAgICAgICAoZXZlbnQgYXMgVG91Y2hFdmVudCkudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCkgLSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgY29uc3QgeSA9XG4gICAgICAoKGV2ZW50IGFzIE1vdXNlRXZlbnQpLnBhZ2VZID8/XG4gICAgICAgIChldmVudCBhcyBUb3VjaEV2ZW50KS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZKSAtIGVsZW1lbnQub2Zmc2V0VG9wO1xuXG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBzaXplIG9mIGEgc3VwcGxpZWQgZWxlbWVudCwgbWludXMgaXRzIHBhZGRpbmcuICovXG4gIHByaXZhdGUgZ2V0RWxlbWVudFNpemVNaW51c1BhZGRpbmcoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBTaXplIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gdGhpcy53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBjb25zdCB3aWR0aCA9XG4gICAgICBlbGVtZW50LmNsaWVudFdpZHRoIC1cbiAgICAgIChwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICtcbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCkpO1xuICAgIGNvbnN0IGhlaWdodCA9XG4gICAgICBlbGVtZW50LmNsaWVudEhlaWdodCAtXG4gICAgICAocGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApICtcbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pKTtcbiAgICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9IGFzIFNpemU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihJTklUSUFMX1NUQVRFKTtcbiAgfVxufVxuIl19